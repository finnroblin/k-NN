/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 *
 * Modifications Copyright OpenSearch Contributors. See
 * GitHub history for details.
 */

 #ifndef KNNPLUGIN_JNI_FAISSINDEXBQ_H
 #define KNNPLUGIN_JNI_FAISSINDEXBQ_H
 
 #include "faiss/IndexFlatCodes.h"
 #include "faiss/Index.h"
 #include "faiss/impl/DistanceComputer.h"
 #include "faiss/utils/hamming_distance/hamdis-inl.h"
 #include <vector>
 #include <iostream>

namespace knn_jni {
    namespace faiss_wrapper {
        struct ADCFlatCodesDistanceComputer1Bit : faiss::FlatCodesDistanceComputer {
            faiss::BinaryFla
            const uint8_t* query;
            int dimension;
            size_t code_size;

            ADCFlatCodesDistanceComputer1Bit(const uint8_t* codes, size_t code_size, int d)
            : FlatCodesDistanceComputer(codes, code_size), dimension(d), query(nullptr) {
                // this->codes = codes;
                // this->code_size = code_size;
                // this->dimension = d;
            }

            virtual float distance_to_code(const uint8_t* code) override {
                float score = 0.0f;
            
                for (int i = 0; i < this->dimension; i++) {
                    score += faiss::hamming<1, float>(code[i], query[i]);
                }

                return score;
            }

            virtual void set_query(const uint8_t* x) override {
                this->query = x;
            };

            virtual float symmetric_dis(faiss::idx_t i, faiss::idx_t j) override {
                std::cout << " in hamming sym dist for some reason...";
                // Just return hamming distance for now...
            retuarn faiss::hamming<1, float>(&this->codes[i], &this->codes[j]);
            };
        };

        struct FaissIndexBQHamming : faiss::IndexFlatCodes {

            FaissIndexBQHamming(faiss::idx_t d, std::vector<uint8_t> codes) : IndexFlatCodes(1, d, faiss::METRIC_L2){
//                 std::cout << "FaissIndexBQ constructor called with codes lenght" << codes.size() << "and codes 0\n";
// //                << codes[0] << "\n";
//                 std::cout << "HEREHERHERH\n\n\n\n\n\n\n\n\n";
                // this->d = d;
                this->codes = codes;
                // this->code_size = 1;
            }

            void init(faiss::Index * parent, faiss::Index * grand_parent) {
                // std::cout << "ehreheragainga\n\n\n\n";
                this->ntotal = this->codes.size() / (this->d / 8);
                parent->ntotal = this->ntotal;
                grand_parent->ntotal = this->ntotal;
            }

            /** a FlatCodesDistanceComputer offers a distance_to_code method */
            faiss::FlatCodesDistanceComputer* get_FlatCodesDistanceComputer() const override {
            //     std::cout << "number of codes: " << this->codes.size() << "\n\n\n HEREHERHEHEREHRHEHRUIHWEUIFHIU\n\\n\n\n\n\n"; // 4400
            //    std::cout << "0th code: " << static_cast<int>(this->codes[0]) << "\n";
            //     std::cout << "ntotal: " << this->ntotal << "\n";
            //     std::cout << "code sz: " << this->code_size << "\n";
            //    std::cout << this->d << "\n";

            //    for (uint8_t code : this->codes) {
            //        std::cout << static_cast<int>(code) << " ";
            //    }

                return new knn_jni::faiss_wrapper::ADCFlatCodesDistanceComputer1Bit((const uint8_t*) (this->codes.data()), 1, this->d);
            };

            virtual void merge_from(faiss::Index& otherIndex, faiss::idx_t add_id = 0) override {
                IndexFlatCodes::merge_from(otherIndex, add_id);
            };

            virtual void search(
                    faiss::idx_t n,
                    const float* x,
                    faiss::idx_t k,
                    float* distances,
                    faiss::idx_t* labels,
                    const faiss::SearchParameters* params = nullptr) const override {
                        IndexFlatCodes::search(n,x,k,distances,labels,params);
                    };
        };
    }
}
#endif //KNNPLUGIN_JNI_FAISSINDEXBQ_H
